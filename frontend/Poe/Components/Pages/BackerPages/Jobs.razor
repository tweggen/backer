@page "/backer/jobs"
@using Hannibal.Client
@using Hannibal.Client.Configuration
@using Hannibal.Models
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Extensions.Options
@using Poe.Services
@using Tools
@rendermode InteractiveServer

@inject IHannibalServiceClient HigginsServiceClient
@inject IHannibalServiceClient HannibalServiceClient
@inject AuthState AuthState
@inject NavigationManager Navigation
@inject Tools.AppBasePath BasePath
@inject IOptions<HannibalServiceClientOptions> HannibalServiceClientOptions
@inject ITokenProvider TokenProvider  

<h3>Backup Jobs</h3>

<div class="alert alert-info mb-4" role="alert">
    <p class="mb-0">
        Jobs are the actual backup tasks that run based on your rules. This screen shows the status of recent and active backup jobs.
        <button type="button" class="info-toggle" @onclick="() => _showJobsDetails = !_showJobsDetails">@(_showJobsDetails ? "less details..." : "more details...")</button>
    </p>
    @if (_showJobsDetails)
    {
        <hr>
        <p class="mb-0"><strong>Job States:</strong></p>
        <ul class="mb-0 mt-2">
            <li><span class="badge bg-info me-1">Preparing</span> — Job is being set up and will start soon.</li>
            <li><span class="badge bg-secondary me-1">Ready</span> — Job is ready to be picked up by the agent.</li>
            <li><span class="badge bg-primary me-1">Executing</span> — Backup is currently in progress.</li>
            <li><span class="badge bg-success me-1">DoneSuccess</span> — Backup completed successfully.</li>
            <li><span class="badge bg-danger me-1">DoneFailure</span> — Backup failed (check logs for details).</li>
        </ul>
        <p class="mt-2 mb-0"><em>This page auto-refreshes when jobs are updated. Use "Clear" to remove completed jobs from the list.</em></p>
    }
</div>

@if (listJobs == null)
{
    <p><em>Loading jobs...</em></p>
}
else
{
    @* === CARD VIEW (used for both mobile and desktop) === *@
    <div class="jobs-card-list">
        @foreach (var job in listJobs)
        {
            <div class="job-card">
                <div class="job-card-header">
                    <span class="job-card-id">#@job.Id</span>
                    @{
                        var jobBadgeClass = job.State switch
                        {
                            Job.JobState.Preparing => "bg-info",
                            Job.JobState.Ready => "bg-secondary",
                            Job.JobState.Executing => "bg-primary",
                            Job.JobState.DoneSuccess => "bg-success",
                            Job.JobState.DoneFailure => "bg-danger",
                            _ => "bg-secondary"
                        };
                    }
                    <span class="badge @jobBadgeClass">@job.State</span>
                </div>
                <div class="job-card-main">
                    <div class="job-card-endpoints">
                        <span class="endpoint">@job.SourceEndpoint.Name</span>
                        <span class="arrow">→</span>
                        <span class="endpoint">@job.DestinationEndpoint.Name</span>
                    </div>
                </div>
                <div class="job-card-times">
                    <span>Start: @FormatDateTime(job.StartFrom)</span>
                    <span>End by: @FormatDateTime(job.EndBy)</span>
                    <span>Updated: @FormatDateTime(job.LastReported)</span>
                </div>
            </div>
        }
    </div>
    
    <button @onclick="_onClearJobs" id="clearJobs" class="btn btn-outline-secondary btn-sm mt-3" title="Remove all completed jobs from the list">Clear Completed Jobs</button>
}

@code {
    private List<Job> listJobs;
    private IdentityUser? _user;
    private HubConnection? hubConnection;
    private bool _showJobsDetails = false;

    /// <summary>
    /// Format a DateTime for display
    /// </summary>
    private string FormatDateTime(DateTime dt)
    {
        var local = dt.ToLocalTime();
        return local.ToString("MM/dd HH:mm");
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }


    private async Task _onClearJobs()
    {
        try
        {
            await HannibalServiceClient.DeleteJobsAsync(CancellationToken.None);
            await _loadJobsAsync();
        }
        catch (Exception e)
        {
            
        }
    }

    
    private async Task _loadJobsAsync()
    {
        try
        {
            listJobs = new List<Job>(
                await HannibalServiceClient.GetJobsAsync(
                    new ResultPage() { Offset = 0, Length = 20 },
                    new JobFilter() { MaxState = Job.JobState.DoneSuccess, MinState = Job.JobState.Preparing },
                    CancellationToken.None
                ));
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception e)
        {
            // Handle error
        }
    }
    
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (AuthState.ReadResetRedirectToLogin())
        {
            await InvokeAsync(() =>
            {
                Task.Delay(200);
                Navigation.NavigateTo("/login");
            });
        }
    }

    
    protected override async Task OnInitializedAsync()
    {
        try
        {
            _user = await HannibalServiceClient.GetUserAsync(-1, CancellationToken.None);
            if (null == _user)
            {
                AuthState.TriggerRedirectToLogin();
                return;
            }

            await _loadJobsAsync();

            await _setupSignalRConnection();
        }
        catch (Exception e)
        {
            // TXWTODO: Catch 401 ?
        }
    }
    

    private async Task _setupSignalRConnection()
    {
        try
        {
            var options = HannibalServiceClientOptions.Value;
            hubConnection = new HubConnectionBuilder()
                .WithUrl($"{options.BaseUrl}/hannibal", httpOptions =>
                {
                    httpOptions.AccessTokenProvider = async () => await TokenProvider.GetToken();
                })
                .WithAutomaticReconnect()
                .Build();

            // Listen for job updates
            hubConnection.On<int, string>("JobUpdated", async (jobId, newState) =>
            {
                // Reload the jobs list when any job is updated
                await _loadJobsAsync();
            });
            
            // Also keep the old "NewJobAvailable" handler for backward compatibility
            hubConnection.On("NewJobAvailable", async () =>
            {
                await _loadJobsAsync();
            });

            await hubConnection.StartAsync();
        }
        catch (Exception ex)
        {
            // Log the error - connection failed
            Console.WriteLine($"SignalR connection failed: {ex.Message}");
        }
    }
}
